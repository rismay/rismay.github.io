{"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/me.rismay.site\/documentation\/Rismay\/swift-s-struct-packing-and-memory-dynamics-inherited-from-c"},"schemaVersion":{"patch":0,"major":0,"minor":3},"metadata":{"role":"article","title":"Swift’s Struct Packing and Memory Dynamics, Inherited from C","roleHeading":"Article"},"abstract":[{"text":"Tags: Blog, C, Programming, Swift","type":"text"},{"text":" ","type":"text"},{"text":"Date: October 30, 2023","type":"text"}],"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"paragraph","inlineContent":[{"text":"Let’s dive into a fascinating topic today - Swift structs and their memory dynamics. In computer programming, particularly in languages like C and C++, “struct packing” refers to the arrangement of data within a struct or structure in memory. The term is often used in the context of memory layout and optimization, especially when dealing with low-level programming and data structures. Swift’s struct packing and memory handling inherit some wisdom from the past, particularly from the world of C programming.","type":"text"}]},{"type":"heading","level":2,"text":"The C Struct","anchor":"The-C-Struct"},{"type":"paragraph","inlineContent":[{"text":"Structs are used to group related data together, and how the elements within a struct are stored in memory can have a significant impact on program performance and memory usage. By default, many compilers will try to align struct members in memory to improve data access performance, which can lead to “padding” or unused bytes between members to meet alignment requirements. For example, consider the following struct in C:","type":"text"}]},{"code":["struct Example {","    char a;    \/\/ 1 byte","    int b;     \/\/ 4 bytes (assuming a typical 32-bit system)","    double c;  \/\/ 8 bytes","};"],"type":"codeListing","syntax":"c"},{"inlineContent":[{"type":"text","text":"In this example, the "},{"inlineContent":[{"type":"codeVoice","code":"struct Example"}],"type":"strong"},{"type":"text","text":" contains a "},{"type":"strong","inlineContent":[{"code":"char","type":"codeVoice"}]},{"type":"text","text":", an "},{"type":"strong","inlineContent":[{"code":"int","type":"codeVoice"}]},{"type":"text","text":", and a "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"double"}]},{"type":"text","text":". The size of this struct, in total, might be larger than the sum of the sizes of its individual members due to padding introduced for alignment. On a typical 32-bit system, you might find that there is 3 bytes of padding added after the "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"char"}]},{"type":"text","text":" member ("},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"a"}]},{"text":") to ensure that the ","type":"text"},{"type":"strong","inlineContent":[{"code":"int","type":"codeVoice"}]},{"text":" member (","type":"text"},{"type":"strong","inlineContent":[{"code":"b","type":"codeVoice"}]},{"type":"text","text":") is properly aligned to a 4-byte boundary. There may also be additional padding at the end of the struct to ensure that the "},{"type":"strong","inlineContent":[{"code":"double","type":"codeVoice"}]},{"text":" member (","type":"text"},{"inlineContent":[{"code":"c","type":"codeVoice"}],"type":"strong"},{"text":") is correctly aligned to an 8-byte boundary.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Now, if you were to change the order of the members like this:"}],"type":"paragraph"},{"syntax":"c","code":["struct Example {","    double c;  \/\/ 8 bytes","    int b;     \/\/ 4 bytes","    char a;    \/\/ 1 byte","};"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The memory layout may change, and the amount of padding introduced may differ. In this case, there might be no padding between the ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"double"}]},{"type":"text","text":" and "},{"inlineContent":[{"type":"codeVoice","code":"int"}],"type":"strong"},{"text":" members, but there could still be padding at the end to align the ","type":"text"},{"inlineContent":[{"code":"double","type":"codeVoice"}],"type":"strong"},{"text":". The total memory size of the struct could be different due to this change in padding.","type":"text"}]},{"inlineContent":[{"type":"text","text":"So, changing the order of variables in a struct can impact the memory size due to differences in alignment requirements. The exact padding added by the compiler can depend on the specific architecture, compiler settings, and data types used in the struct. To minimize padding and control memory layout, you can use compiler-specific directives or attributes (such as "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"__attribute__((packed))"}]},{"type":"text","text":" in GCC) or reorder the struct members strategically based on the alignment requirements of your target system. However, optimizing for memory size may come at the cost of performance, as unaligned access to data can be slower on some architectures."}],"type":"paragraph"},{"anchor":"Intro-to-Swift-Structs","type":"heading","text":"Intro to Swift Structs","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Before we unravel the magic of struct packing, let’s have a quick refresher on what a Swift struct is all about. Imagine a struct as a handy way to bundle related data into a neat package. Each piece of data inside a struct is called a member. Here’s a basic example:"}]},{"syntax":"swift","type":"codeListing","code":["struct Point {","    var x: Double","    var y: Double","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, we’ve got a struct named "},{"type":"codeVoice","code":"Point"},{"type":"text","text":" with two "},{"type":"codeVoice","code":"Double"},{"text":" members, ","type":"text"},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":". It’s like having a mini-coordinate system in a single entity."}]},{"anchor":"The-Legacy-of-Memory-Layout","level":2,"type":"heading","text":"The Legacy of Memory Layout"},{"inlineContent":[{"type":"text","text":"Swift doesn’t reinvent the wheel when it comes to memory layout and alignment. It takes a page from the C playbook. Every data type has an alignment requirement, specifying how it should line up in memory. For example, "},{"type":"codeVoice","code":"double"},{"type":"text","text":" usually needs an 8-byte alignment, while "},{"type":"codeVoice","code":"int"},{"type":"text","text":" might need 4 bytes."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Swift’s goal is to make sure each struct member lines up properly. If it has to, it throws in some padding bytes to meet alignment requirements. Padding might sound like a bit of a buzzkill, but it’s essential to ensure efficient memory access. I hear that you don’t want to deal with the sluggishness of unaligned memory operations."}],"type":"paragraph"},{"anchor":"Swifts-Struct-Packing-Saga-Inspired-by-C","level":2,"text":"Swift’s Struct Packing Saga, Inspired by C","type":"heading"},{"inlineContent":[{"text":"Swift aims for optimal memory usage and speedy access, and it carries over some concepts from C. In Swift, the memory layout and alignment of structs are managed by the Swift compiler, and it aims to provide a more predictable and consistent behavior compared to some other programming languages like C and C++. However, Swift structs can still be affected by memory alignment and padding, but the compiler makes efforts to minimize these issues.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift automatically aligns struct members according to their types and alignment requirements, just like in other languages. This alignment is designed to optimize access times and ensure memory safety. Swift also provides control over memory layout in the form of compiler attributes and annotations, such as ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"@alignment"}]},{"text":" and ","type":"text"},{"type":"strong","inlineContent":[{"code":"@packed","type":"codeVoice"}]},{"text":", which can be used to control alignment and packing if necessary. However, there’s room for your input to fine-tune struct packing:","type":"text"}],"type":"paragraph"},{"anchor":"1-Its-All-About-Member-Order","level":3,"text":"1. It’s All About Member Order","type":"heading"},{"inlineContent":[{"type":"text","text":"Just like in C, the order of members in a struct can shake things up in the memory layout. Swift tends to put the larger members upfront to minimize padding. It’s like playing a game of Tetris with your data. Take this struct, for instance:"}],"type":"paragraph"},{"code":["struct Employee {","    var salary: Double  \/\/ 8 bytes","    var employeeID: Int \/\/ 4 bytes","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In this struct, ","type":"text"},{"code":"salary","type":"codeVoice"},{"text":" takes the lead to minimize padding, just like how C would do it.","type":"text"}],"type":"paragraph"},{"anchor":"2-Go-for-Slimmer-Data-Types","level":3,"text":"2. Go for Slimmer Data Types","type":"heading"},{"inlineContent":[{"text":"If memory is important opt for smaller data types, such as ","type":"text"},{"type":"codeVoice","code":"Int32"},{"text":" instead of ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":", to keep the memory footprint lean. Smaller data types typically come with smaller alignment requirements and less padding. Here’s an example:","type":"text"}],"type":"paragraph"},{"code":["struct SensorData {","    var value: Int32  \/\/ 4 bytes","    var timestamp: Double \/\/ 8 bytes","}"],"syntax":"swift","type":"codeListing"},{"anchor":"3-The-packed-Attribute","level":3,"text":"3. The `@packed` Attribute","type":"heading"},{"inlineContent":[{"type":"text","text":"Swift throws a wildcard into the mix with the "},{"type":"codeVoice","code":"@packed"},{"type":"text","text":" attribute. Apply it to a struct if you want to minimize padding, akin to C’s packed attribute. But tread carefully, as it might impact performance on certain systems:"}],"type":"paragraph"},{"code":["struct MyStruct {","    var a: Int32","    var b: Double","} @packed"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","anchor":"4-Beware-of-Reference-Types","text":"4. Beware of Reference Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Stay cautious with reference types like classes within a struct. They bring along some extra memory overhead, another lesson inherited from C. Remember, structs are all about values, so adding reference types can bulk up their size."}]},{"level":2,"type":"heading","anchor":"Determining-the-size-of-Swift-structs","text":"Determining the size of Swift structs"},{"type":"paragraph","inlineContent":[{"text":"In Swift, you can determine the size of a struct or any data type using the ","type":"text"},{"type":"codeVoice","code":"MemoryLayout"},{"text":" struct and its ","type":"text"},{"type":"codeVoice","code":"size"},{"text":" property. ","type":"text"},{"type":"codeVoice","code":"MemoryLayout"},{"text":" is a generic struct that provides information about the memory layout and size of Swift types. Here’s how you can use it to find the size of a struct:","type":"text"}]},{"code":["struct MyStruct {","    var a: Int","    var b: Double","}","","let sizeOfMyStruct = MemoryLayout<MyStruct>.size","print(\"Size of MyStruct: \\\\(sizeOfMyStruct) bytes\")"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In the code above, we define a struct ","type":"text"},{"code":"MyStruct","type":"codeVoice"},{"text":" with two members, an ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" and a ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":". We then use ","type":"text"},{"code":"MemoryLayout<MyStruct>.size","type":"codeVoice"},{"text":" to obtain the size of ","type":"text"},{"code":"MyStruct","type":"codeVoice"},{"text":" in bytes and print it to the console.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will give you the size of the struct in bytes as it would be laid out in memory. Keep in mind that the actual size of a struct can be affected by factors like padding and alignment, which are determined by the Swift compiler to optimize memory access and performance. The "},{"code":"MemoryLayout","type":"codeVoice"},{"type":"text","text":" struct provides information based on the compiler’s decisions."}]},{"type":"heading","text":"The Delicate Balance","anchor":"The-Delicate-Balance","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, here’s the catch: optimizing struct packing is like walking a tightrope. You want a sleek memory footprint, but you also crave top-notch performance. Overdoing it with packing and alignment tweaks can lead to performance hiccups, especially on architectures that demand strict alignment."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always keep an eye on memory usage and performance by profiling your application. It’s the only way to ensure your optimizations hit the bullseye without introducing unexpected side effects."}]},{"inlineContent":[{"type":"text","text":"In the grand scheme of things, Swift’s memory layout and struct packing principles have a rich lineage from C. This inheritance ensures that Swift strikes a harmonious balance between memory efficiency and performance, benefiting from the wisdom and experience of its predecessor."}],"type":"paragraph"},{"inlineContent":[{"text":"So, fellow Swift enthusiasts, go forth and craft those memory-efficient structs while keeping your code clean and snappy. Swift is the future, and it brings along a bit of the past to make it even better.","type":"text"}],"type":"paragraph"}],"kind":"content"}],"kind":"article","hierarchy":{"paths":[["doc:\/\/me.rismay.site\/documentation\/rismay-me"]]},"seeAlsoSections":[{"identifiers":["doc:\/\/me.rismay.site\/documentation\/Rismay\/navigating-the-performance-penalties-of-swift-type-inference","doc:\/\/me.rismay.site\/documentation\/Rismay\/im-on-getting-rismay-me-working","doc:\/\/me.rismay.site\/documentation\/Rismay\/whoa","doc:\/\/me.rismay.site\/documentation\/Rismay\/it-begins","doc:\/\/me.rismay.site\/documentation\/Rismay\/daily-entry","doc:\/\/me.rismay.site\/documentation\/Rismay\/wsmlogger-an-nslog-replacement-for-debugging-multithreaded-code","doc:\/\/me.rismay.site\/documentation\/Rismay\/1500-13-late-2013-rmbp-vs-1600-15-2012-rmbp-portability-vs-performance","doc:\/\/me.rismay.site\/documentation\/Rismay\/coding-as-an-art-method-acting","doc:\/\/me.rismay.site\/documentation\/Rismay\/core-location-evolution","doc:\/\/me.rismay.site\/documentation\/Rismay\/thoughts-on-minimizing-friction"],"title":"Blog","anchor":"Blog","generated":true}],"references":{"doc://me.rismay.site/documentation/Rismay/wsmlogger-an-nslog-replacement-for-debugging-multithreaded-code":{"abstract":[{"type":"text","text":"The most effective debugging tool is still careful thought, coupled with judiciously placed print statements."}],"role":"article","identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/wsmlogger-an-nslog-replacement-for-debugging-multithreaded-code","kind":"article","title":"WSMLogger: An NSLog replacement for Debugging Multithreaded code","url":"\/documentation\/rismay\/wsmlogger-an-nslog-replacement-for-debugging-multithreaded-code","type":"topic"},"doc://me.rismay.site/documentation/Rismay/im-on-getting-rismay-me-working":{"identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/im-on-getting-rismay-me-working","kind":"article","url":"\/documentation\/rismay\/im-on-getting-rismay-me-working","abstract":[{"type":"text","text":"Tags: Blog, Daily"},{"text":" ","type":"text"},{"type":"text","text":"Date: June 1, 2020 12:00 AM (PDT)"}],"role":"article","title":"I’m On Getting rismay.me working","type":"topic"},"doc://me.rismay.site/documentation/Rismay/it-begins":{"identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/it-begins","role":"article","url":"\/documentation\/rismay\/it-begins","kind":"article","abstract":[{"type":"text","text":"Tags: Atom, Blog, Daily, Evernote, imdone"}],"title":"It Begins","type":"topic"},"doc://me.rismay.site/documentation/Rismay/daily-entry":{"type":"topic","identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/daily-entry","url":"\/documentation\/rismay\/daily-entry","abstract":[{"type":"text","text":"Tags: Daily"}],"role":"article","title":"Daily Entry","kind":"article"},"doc://me.rismay.site/documentation/Rismay/core-location-evolution":{"identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/core-location-evolution","url":"\/documentation\/rismay\/core-location-evolution","type":"topic","kind":"article","title":"Core Location Evolution","role":"article","abstract":[{"type":"text","text":"TL;DR: Apple has been refining their location APIs opportunistically to improve battery life."}]},"doc://me.rismay.site/documentation/rismay-me":{"url":"\/documentation\/rismay-me","kind":"article","type":"topic","abstract":[{"type":"text","text":"An engineer and designer focused on developer tools, creative systems, and agentic workflows."}],"identifier":"doc:\/\/me.rismay.site\/documentation\/rismay-me","role":"article","title":"Rismay"},"doc://me.rismay.site/documentation/Rismay/navigating-the-performance-penalties-of-swift-type-inference":{"abstract":[{"type":"text","text":"In the world of programming languages, Swift has emerged as a dynamic and versatile option. Its type inference feature, while powerful, isn’t without its quirks. Like any technological innovation, Swift’s type inference has its own set of performance considerations that developers should be aware of. In this blog post, we’ll delve into the fascinating realm of Swift’s type inference and explore how it can sometimes impose performance penalties."}],"role":"article","identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/navigating-the-performance-penalties-of-swift-type-inference","kind":"article","title":"Navigating the Performance Penalties of Swift Type Inference","url":"\/documentation\/rismay\/navigating-the-performance-penalties-of-swift-type-inference","type":"topic"},"doc://me.rismay.site/documentation/Rismay/coding-as-an-art-method-acting":{"identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/coding-as-an-art-method-acting","kind":"article","url":"\/documentation\/rismay\/coding-as-an-art-method-acting","abstract":[{"type":"text","text":"This might sound weird, but my experience acting is the most relevant study\/project\/work I’ve done to prepare me as a developer."}],"role":"article","title":"Coding as an Art: Method Acting","type":"topic"},"doc://me.rismay.site/documentation/Rismay/whoa":{"type":"topic","role":"article","kind":"article","identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/whoa","abstract":[{"text":"Tags: Blog","type":"text"}],"title":"Whoa…","url":"\/documentation\/rismay\/whoa"},"doc://me.rismay.site/documentation/Rismay/thoughts-on-minimizing-friction":{"identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/thoughts-on-minimizing-friction","url":"\/documentation\/rismay\/thoughts-on-minimizing-friction","type":"topic","kind":"article","title":"Thoughts on Minimizing Friction","role":"article","abstract":[{"type":"text","text":"Tags: Blog, EC2, Evernote, Historical, Moves, github, postach.io, tumblr, twitter"}]},"doc://me.rismay.site/documentation/Rismay/1500-13-late-2013-rmbp-vs-1600-15-2012-rmbp-portability-vs-performance":{"role":"article","title":"$1500 13” Late 2013 rMBP vs $1600 15” 2012 rMBP? Portability vs Performance","identifier":"doc:\/\/me.rismay.site\/documentation\/Rismay\/1500-13-late-2013-rmbp-vs-1600-15-2012-rmbp-portability-vs-performance","url":"\/documentation\/rismay\/1500-13-late-2013-rmbp-vs-1600-15-2012-rmbp-portability-vs-performance","abstract":[{"type":"text","text":"I previously posted that I returned my Late 2013 13” rMBP after I encountered the dreaded unresponsive keyboard glitch. This is a bit disingenuous because the ultimate reason I returned the notebook was to purchase a more powerful version of the same laptop after the Keyboard\/Trackpad problems were confirmed to be software issues. However, when I went to look at my buying options, I discover that Apple was offering the original 2012 15” rMBP for $1600. That’s $500 off for a laptop that comes with a 1 year warranty. This post is simply to help those wondering: Should you pay $100 more for a refurbished original 15” Retina Macbook Pro vs a new Late 2013 13” MacBook Pro Retina?"}],"kind":"article","type":"topic"}}}